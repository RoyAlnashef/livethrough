# Code Style Guide

> Version: 1.2.0
> Last Updated: 2025-01-27
> Based on: LiveThrough Project Analysis

## Context

This file is part of the Agent OS standards system. These global code style rules are referenced by all product codebases and provide default formatting guidelines. Individual projects may extend or override these rules in their `.agent-os/product/code-style.md` file.

## Core Development Principles

### Code Quality Standards
- **DRY Principle**: Don't Repeat Yourself - avoid code duplication
- **Readability First**: Prioritize easy-to-read code over performance optimizations
- **Complete Implementation**: Leave NO todos, placeholders, or missing pieces
- **Bug-Free Code**: Ensure all code is fully functional and working
- **Best Practices**: Follow established patterns and conventions

### Development Approach
- **Step-by-Step Planning**: Always think through implementation in pseudocode first
- **Confirmation**: Confirm requirements before writing code
- **Thorough Verification**: Verify code is complete and finalized
- **Concise Communication**: Minimize unnecessary prose in code and documentation

## General Formatting

### Indentation
- Use 2 spaces for indentation (never tabs)
- Maintain consistent indentation throughout files
- Align nested structures for readability

### File Extensions
- **React Components**: `.tsx` for TypeScript components, `.jsx` for JavaScript
- **Utility Files**: `.ts` for TypeScript, `.js` for JavaScript
- **Configuration**: `.json`, `.mjs`, `.config.js`

### Quote Usage
- **Strings**: Use double quotes consistently (`"string"`)
- **JSX Attributes**: Use double quotes (`className="..."`)
- **Template Literals**: Use backticks for interpolation (``${variable}`)

## Naming Conventions

### React Components
- **Components**: Use PascalCase (e.g., `Header`, `CourseCard`, `LiveThroughFooter`)
- **Component Files**: Use PascalCase to match component name (e.g., `Header.tsx`, `CourseCard.tsx`)
- **Exports**: Use named exports consistently with const arrow functions (`export const ComponentName`)

### Variables and Functions
- **Variables**: Use camelCase (e.g., `userProfile`, `isAuthenticated`, `courseData`)
- **Functions**: Use camelCase (e.g., `handleSubmit`, `fetchCourses`, `toggleMenu`)
- **Boolean Variables**: Use `is`, `has`, `can` prefixes (e.g., `isLoading`, `hasError`, `canEdit`)
- **Event Handlers**: Use "handle" prefix (e.g., `handleClick`, `handleKeyDown`, `handleSubmit`)

### Constants and Types
- **Constants**: Use UPPER_SNAKE_CASE (e.g., `MAX_RETRY_COUNT`, `API_BASE_URL`)
- **TypeScript Interfaces**: Use PascalCase with descriptive names (e.g., `CourseType`, `UserProfile`)
- **Type Aliases**: Use PascalCase (e.g., `CourseStatus`, `ApiResponse`)

### File and Directory Names
- **Directories**: Use kebab-case (e.g., `course-marketplace/`, `auth-actions/`)
- **Component Files**: Use PascalCase to match component names (e.g., `Header.tsx`, `CourseCard.tsx`)
- **Utility Files**: Use kebab-case (e.g., `auth-context.tsx`, `image-processing.ts`)

## React/JSX Formatting

### Component Structure
```tsx
"use client" // If client component

import { useState } from "react"
import { Button } from "@/components/ui/button"
import { cn } from "@/lib/utils"

interface ComponentProps {
  title: string
  isActive?: boolean
  onToggle: () => void
}

export const Component = ({ title, isActive = false, onToggle }: ComponentProps): JSX.Element => {
  const [isOpen, setIsOpen] = useState(false)

  const handleClick = (): void => {
    setIsOpen(!isOpen)
    onToggle()
  }

  return (
    <div className="container mx-auto px-4">
      <h1 className="text-2xl font-bold">{title}</h1>
      <Button 
        onClick={handleClick}
        className={cn(
          "bg-primary text-white",
          isActive && "bg-secondary"
        )}
      >
        Toggle
      </Button>
    </div>
  )
}
```

### Function Declaration Style
- **Prefer const arrow functions** over function declarations for consistency
- **Always define types** when possible for better type safety
- **Use explicit return types** for all functions, especially complex ones

```tsx
// Preferred: const arrow functions with explicit types
const handleSubmit = (event: React.FormEvent<HTMLFormElement>): void => {
  event.preventDefault()
  // Implementation
}

const fetchUserData = async (userId: string): Promise<User> => {
  // Implementation
}

// For complex functions, use explicit return types
const processData = (data: RawData[]): ProcessedData[] => {
  // Implementation
}

// Exception: Type guards can use function declarations for better type inference
function isCourse(obj: unknown): obj is Course {
  return typeof obj === "object" && obj !== null && "title" in obj
}
```

### Early Returns Pattern
- **Use early returns** whenever possible to make code more readable
- **Reduce nesting** and improve code flow

```tsx
// Good: Early returns for better readability
const validateForm = (data: FormData): ValidationResult => {
  if (!data.email) {
    return { isValid: false, error: "Email is required" }
  }
  
  if (!data.password) {
    return { isValid: false, error: "Password is required" }
  }
  
  if (data.password.length < 8) {
    return { isValid: false, error: "Password must be at least 8 characters" }
  }
  
  return { isValid: true, error: null }
}

// Avoid: Deep nesting
const validateFormBad = (data: FormData): ValidationResult => {
  if (data.email) {
    if (data.password) {
      if (data.password.length >= 8) {
        return { isValid: true, error: null }
      } else {
        return { isValid: false, error: "Password must be at least 8 characters" }
      }
    } else {
      return { isValid: false, error: "Password is required" }
    }
  } else {
    return { isValid: false, error: "Email is required" }
  }
}
```

### JSX Attributes
- Place each attribute on its own line for readability
- Keep closing `>` on the same line as the last attribute
- Use template literals for dynamic class names with `cn()` utility

### Import Management
```tsx
// 1. React and Next.js imports
import { useState, useEffect } from "react"
import { useRouter } from "next/navigation"
import Image from "next/image"

// 2. Third-party libraries
import { Button } from "@/components/ui/button"
import { cn } from "@/lib/utils"

// 3. Local imports (absolute paths)
import { Course } from "@/lib/types"
import { useAuth } from "@/lib/auth-context"

// 4. Local imports (relative paths)
import { CourseCard } from "./CourseCard"
import { useAuthModal } from "./auth-modal-context"
```

**Import Guidelines:**
- **Remove unused imports** when components are removed from files
- **Keep imports organized** in the numbered structure above
- **Use absolute paths** for shared components and utilities
- **Group imports** by category with clear separation

## Accessibility Guidelines

### Interactive Elements
- **Always implement accessibility features** on interactive elements
- **Include proper ARIA attributes** and keyboard navigation

```tsx
// Good: Accessible button with keyboard support
const handleKeyDown = (event: React.KeyboardEvent): void => {
  if (event.key === "Enter" || event.key === " ") {
    event.preventDefault()
    handleClick()
  }
}

return (
  <button
    onClick={handleClick}
    onKeyDown={handleKeyDown}
    tabIndex={0}
    aria-label="Toggle menu visibility"
    className="p-2 rounded-md hover:bg-gray-100 focus:ring-2 focus:ring-blue-500"
  >
    <MenuIcon className="w-5 h-5" />
  </button>
)

// Good: Accessible link with proper attributes
<a
  href="/courses"
  tabIndex={0}
  aria-label="Navigate to courses page"
  onKeyDown={(e): void => e.key === "Enter" && e.currentTarget.click()}
  className="text-blue-600 hover:text-blue-800 focus:ring-2 focus:ring-blue-500 rounded"
>
  View Courses
</a>
```

### Form Accessibility
```tsx
// Good: Accessible form with proper labels and error handling
<form onSubmit={handleSubmit} className="space-y-4">
  <div>
    <label htmlFor="email" className="block text-sm font-medium text-gray-700">
      Email Address
    </label>
    <input
      id="email"
      type="email"
      name="email"
      required
      aria-describedby="email-error"
      className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500"
    />
    {emailError && (
      <p id="email-error" className="mt-1 text-sm text-red-600" role="alert">
        {emailError}
      </p>
    )}
  </div>
</form>
```

## TypeScript Conventions

### Interface Definitions
```tsx
interface Course {
  id: string
  title: string
  description?: string
  price: number
  duration: number
  difficulty: "Beginner" | "Intermediate" | "Advanced"
  environment: string[]
  photo_url: string[]
  created_at?: string
}

interface ApiResponse<T> {
  data: T
  error?: string
  status: number
}
```

### Type Guards and Utilities
```tsx
// Type guards (exception: can use function declarations for better type inference)
function isCourse(obj: unknown): obj is Course {
  return typeof obj === "object" && obj !== null && "title" in obj
}

// Utility types
type CourseStatus = "Draft" | "Published" | "Archived"
type CourseFilters = Partial<Pick<Course, "difficulty" | "environment">>
```

### Type Definitions
- **Always define types** when possible for better type safety
- **Use explicit return types** for complex functions
- **Prefer interfaces** for object shapes and types for unions/primitives

```tsx
// Good: Explicit types
const calculateTotal = (items: CartItem[]): number => {
  return items.reduce((total, item) => total + item.price * item.quantity, 0)
}

// Good: Type definitions for complex data
type UserRole = "admin" | "instructor" | "student"
type CourseDifficulty = "Beginner" | "Intermediate" | "Advanced"

interface User {
  id: string
  email: string
  role: UserRole
  profile: UserProfile
}
```

## Error Handling

### Try-Catch Patterns with Early Returns
```tsx
// Good: Early returns in error handling
const parseData = (data: string): ParsedData | null => {
  try {
    const parsed = JSON.parse(data)
    return parsed
  } catch (error) {
    console.warn("Failed to parse data:", error)
    return null
  }
}

// Good: Async error handling with early returns
const fetchData = async (url: string): Promise<ApiResponse<Data> | null> => {
  try {
    const response = await fetch(url)
    
    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }
    
    const result = await response.json()
    return result
  } catch (error) {
    console.error("API call failed:", error)
    return null
  }
}

// Good: Validation with early returns
const validateUserInput = (input: UserInput): ValidationResult => {
  if (!input.email) {
    return { isValid: false, error: "Email is required" }
  }
  
  if (!input.password) {
    return { isValid: false, error: "Password is required" }
  }
  
  try {
    // Additional validation logic
    return { isValid: true, error: null }
  } catch (error) {
    return { isValid: false, error: "Validation failed" }
  }
}
```

### Error Boundaries
- Use React Error Boundaries for component-level error handling
- Log errors to console with descriptive messages
- Provide fallback UI for failed components

## TailwindCSS Guidelines

### Styling Approach
- **Always use Tailwind classes** for styling HTML elements
- **Avoid using CSS or style tags** unless absolutely necessary
- **Use `cn()` utility** for conditional classes instead of ternary operators

### Class Organization
Use the `cn()` utility function for conditional classes and organize classes in this order:

```tsx
className={cn(
  // 1. Layout & positioning
  "flex items-center justify-between",
  
  // 2. Spacing & sizing
  "p-4 w-full h-16",
  
  // 3. Typography
  "text-lg font-semibold",
  
  // 4. Colors & backgrounds
  "bg-white text-black dark:bg-gray-900 dark:text-white",
  
  // 5. Borders & shadows
  "border border-gray-200 rounded-lg shadow-sm",
  
  // 6. Interactive states
  "hover:bg-gray-50 focus:ring-2 focus:ring-blue-500",
  
  // 7. Responsive variants
  "md:p-6 lg:text-xl",
  
  // 8. Conditional classes (use && instead of ternary)
  isActive && "bg-blue-500 text-white",
  isDisabled && "opacity-50 cursor-not-allowed"
)}
```

### Conditional Classes
- **Use `&&` operator** instead of ternary operators for conditional classes
- **Keep conditional logic simple** and readable

```tsx
// Good: Using && for conditional classes
<div className={cn(
  "base-classes",
  isActive && "active-classes",
  isDisabled && "disabled-classes"
)}>

// Avoid: Ternary operators for simple conditions
<div className={cn(
  "base-classes",
  isActive ? "active-classes" : "",
  isDisabled ? "disabled-classes" : ""
)}>
```

### Multi-line Class Organization
For complex components, organize Tailwind classes by category:

```tsx
<div className="
  // Layout
  flex flex-col space-y-4
  md:flex-row md:space-y-0 md:space-x-6
  
  // Spacing & sizing
  p-6 w-full max-w-4xl
  
  // Colors & backgrounds
  bg-white dark:bg-gray-900
  
  // Borders
  border border-gray-200 dark:border-gray-700 rounded-lg
  
  // Interactive
  hover:shadow-lg transition-shadow
">
```

## Code Comments

### When to Comment
- Add JSDoc comments for complex functions and components
- Document business logic that isn't immediately obvious
- Explain the "why" behind implementation choices
- Comment on TypeScript types for complex interfaces

### Comment Format
```tsx
/**
 * Fetches course data from the API with optional filtering
 * @param filters - Optional filters to apply to the query
 * @param page - Page number for pagination (default: 1)
 * @returns Promise containing course data and pagination info
 */
const fetchCourses = async (filters?: CourseFilters, page = 1): Promise<ApiResponse<Course[]>> => {
  // Implementation here
}

// Inline comments for complex logic
const processedCourses = courses
  .filter(course => course.status === "Published") // Only show published courses
  .sort((a, b) => new Date(b.created_at).getTime() - new Date(a.created_at).getTime()) // Sort by newest first
```

## File Organization

### Component Structure
```
components/
├── ui/                    # Base UI components (shadcn/ui)
├── layout/               # Layout components (Header, Footer, etc.)
├── course-marketplace/   # Feature-specific components
├── dashboard/           # Dashboard-specific components
└── shared/             # Shared components across features
```

### Utility Organization
```
lib/
├── utils.ts             # General utilities (cn function)
├── types.ts             # TypeScript type definitions
├── supabase.ts          # Supabase client configuration
├── auth-context.tsx     # Authentication context
└── actions.ts           # Server actions
```

### File Naming Patterns
- **Components**: `ComponentName.tsx` (PascalCase to match component name)
- **Utilities**: `utility-name.ts` (kebab-case)
- **Hooks**: `useHookName.ts` (camelCase with `use` prefix)
- **Types**: `types.ts` or `component-name.types.ts`

## Development Workflow

### Code Implementation Process
1. **Plan First**: Think step-by-step and describe the plan in pseudocode
2. **Confirm Requirements**: Verify understanding before implementation
3. **Write Complete Code**: Implement all functionality without placeholders
4. **Verify Thoroughly**: Ensure code is complete and functional
5. **Include All Imports**: Add all required imports and dependencies
6. **Clean Up**: Remove unused imports and code

### Quality Assurance
- **No TODOs**: Complete all implementation before submission
- **No Placeholders**: Replace all placeholder content with actual implementation
- **Bug-Free**: Ensure code runs without errors
- **DRY Principle**: Avoid code duplication
- **Readability**: Prioritize clear, readable code over performance

---

*This code style guide is based on the LiveThrough project analysis and cursor.rules guidelines. Customize this file with your team's specific style preferences. These formatting rules apply to all code written by humans and AI agents.*
